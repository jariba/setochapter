\subsection{Architecture}
\label{sec:europa:arch}

\eu is implemented as a library that encapsulates all elements
described above making them accessible via modeling and Application
Programming Interface (API) layers.  A user will typically use the
modeling facilities to inject a problem domain description and the
API to extract and manipulate plans and to obtain information about
plan flaws and constraint violations at any stage of the planning
process.

\begin{figure}
\centering
\includegraphics[scale=0.4]{figs/EUROPA-Architecture.pdf}
\caption{\small The \eu software architecture.}
\label{fig:europa-architecture}
\end{figure}

Fig. \ref{fig:europa-architecture} shows the main architectural
components in \eu and their relationships. The \textbf{Constraint
  Reasoning Engine} (\texttt{CRE}) manages domain types, variables and
constraints that define relationships among them. It also provides an
efficient arc consistency mechanism \cite{mackworth77}. The
\texttt{CRE} is designed so that specialized reasoning algorithms for
new constraints can be easily and efficiently plugged in. The
\textbf{Plan Database} (\texttt{PDB}) manages object and token
types. It also maintains the state of partial plans in terms of
object, variable and token instances. This constitutes the data
foundation on which end user applications and automated planners
within \eu are built. The \textbf{Rules Engine} (\texttt{RE})
modularly adds the semantics of domain rules that describe
dependencies between tokens. The \textbf{Solver Module} provides the
framework for flaw detection and resolution that is needed to
implement search algorithms for planning. The \textbf{API Layer}
provides access to services from all the different modules in a
programmatic way so that \eu can be easily embedded into specialized
applications.

Describing problem domains and problem instances in terms of objects,
variables and domain rules in a programmatic way is cumbersome to the
extent of being impractical; this motivated the creation of modeling
languages that support those definitions in a much more natural and
compact way. \texttt{NDDL} (New Domain Description Language
[pronounced ``noodle'']) \cite{NDDL} is the main modeling language for
\eu and will be described in detail in the Modeling section
below. Another, \texttt{ANML} is a language under development that
provides a more intuitive syntax \cite{smith08}.
  
In an effort to mimimize the amount of work that a user needs to
perform to solve specific problems, \eu also bundles extension
modules that have been found to be useful in many domains:

\begin{enumerate}

\item \textit{Temporal Network}: Extensions to the \texttt{CRE} module to
  reason about temporal constraints

\item \textit{Resources}: Extensions to the \texttt{CRE}, \texttt{PDB}
  and Solver modules to provide reasoning and search for metric
  resources.

\item \textit{Chronological Backtracking Solver}: A general purpose
  built-in solver to provide the ability to plan out-of-the-box.
  Problems that require challenging search may require specialized
  solvers to be built as explained in Section \ref{sec:europa:search}.

\end{enumerate}

\subsection{Modeling in \eu}
\label{sec:europa:modeling}

\eu can ingest descriptions of models, plans and goals and thereby can
be applied to different domains and problems, simply by providing
different models and goals. Consequently the expressiveness of the
language for models, goals and plans is of great importance. For \eue,
\texttt{NDDL} allows the user to specify the different components of a
problem domain in a precise and concise manner. Among the main
features that make \texttt{NDDL} a powerful tool for describing
problem domains are that it is object oriented. \texttt{NDDL} supports
classes and inheritance in similar fashion to popular Object-Oriented
languages like Java and C++. It also supports polymorphism for some of
the planning components. Using object classes and instances is a
time-tested approach to naturally describe problem domains
\cite{rumbaugh}. It offers declarative constructs to define
constraints and causality dependencies between actions and effects and
finally it offers procedural constructs to populate \eus plan
database with specific problem instances expressed in terms of
objects, variables, constraints, facts and goals. To articulate
important elements of \texttt{NDDL}, we show how the Shopping Agent
problem could be modeled:

\begin{verbatim}

// Locations (Home, SuperMarket, etc.)
class Location {
  string name;
  Location(string _name){
    name = _name;
  }
}

// Products (Milk, Banana, etc.) and
class Product {
  string name;
  Product(string _name) {
    name = _name;
  }
}

// ProductLocations (Banana can be found at SuperMarket, for example)
class ProductLocation {
  Location location;
  Product product;

  ProductLocation(Location _location, Product _product){
    location = _location;
    product = _product;
  }
}

// Use built-in Timeline functionality to enforce that an agent:
// a) Can't be at more than one place at a time.
// b) Can't Go more than one place at a time.
// c) Can't Go somewhere and be At somewhere at the same time.
class AgentLocation extends Timeline{
  predicate At {
    Location loc;
  }

  predicate Going {
    Location from;
    Location to;
  }
}

// In addition to having a location timeline, the agent can buy and own things.  
// Note that the actions and the location predicates can be concurrent 
// so they can't be on the same Timeline
class Agent {
  AgentLocation location;

  Agent() {
    location = new AgentLocation();
  }

  action Buy {
    Product product;
  }
  
  action Go {
    Location from;
    Location to;
  }
  
  predicate Own {
  	Product product;
  }
}
\end{verbatim}

In the model above one can see the main elements of a problem domain
can be mapped to \eus representation:

\begin{description}

\item[\textbf{Object Types}]: \texttt{NDDL} supports an object-oriented
  approach, where common data and behavior can be abstracted as a
  class. In this case, we have the \textit{Product} class represent
  the products that the Shopping Agent needs, \textit{Location}
  represents the places where products can be found,
  \textit{ProductLocation} represents the association arising when a
  product can be purchased at a location. The Shopping Agent itself is
  represented by an \textit{Agent} class, which relies on the
  \textit{AgentLocation} class to keep track of where the agent is at
  any point in time. \texttt{NDDL} supports a single rooted class
  hierarchy so that state and behavior can be extended through
  inheritance. We take advantage of that feature by making
  \textit{AgentLocation} inherit from \eus built-in \textit{Timeline}
  class which doesn't allow predicates to overlap in time for the same
  object instance. This feature is used for instance, to ensure that
  an agent can only be at one place at a time in our example.

\item[\textbf{Variable Types and Instances}]: All object attributes
  are represented as variables in this model. For instance, it uses
  integer variables to represent the built-in temporal parameters for
  each token (activity duration, start and end times), string
  variables to represent \textit{Location} and \textit{Product} names,
  and object reference variables to represent the structural
  relationships between different objects (for instance, each Agent
  maintains a variable to keep track of its \textit{AgentLocation}).

\item[\textbf{Predicate Types}]: Some classes like \textit{Product},
  \textit{Location} and \textit{ProductLocation} are static and so
  don't have any predicate or action types associated with them. The
  \textit{AgentLocation} class is used to keep track of state and so
  has \texttt{At} and \texttt{Going} predicate types associated with
  it. The \textit{Agent} class keeps track of the products it
  purchases through the \texttt{Own} predicate; having a separate
  \textit{AgentBag} class with its own predicates would have been an
  equally valid modeling choice.

\item[\textbf{Action Types}]: In our example, \textit{Agent} is solely
  the class that has behavior associated with it. Consequently, it
  defines action types to represent when the agent is taking action to
  \texttt{Go} to a \textit{Location}, or to \texttt{Buy} a
  \textit{Product}. % We'll see how the actual behavior for those
  % actions is specified below.

\end{description}

\begin{verbatim}

// Define the rules for our actions:
Agent::Go {
  met_by(condition object.location.At origin);
  eq(from, origin.loc);
 
  equals(effect object.location.Going going);
  eq(going.from, from);
  eq(going.to, to);
   
  meets(effect object.location.At destination);
  eq(to, destination.loc);
}

Agent::Buy {
  // A Buy takes 10 time units
  eq(10, duration);

  // initialized to all locations
  ProductLocation possibleStores;

  // limit possibleStores variables to ones that provide what we need to buy
  eq(product, possibleStores.product);

  // We must be At a location during our Buy, and that location must have the
  // product we want available:
  contained_by(condition object.location.At currLocation);
  eq(currLocation.loc, possibleStores.location);
  
  meets(effect Own purchase);
  eq(purchase.product,product);
}
\end{verbatim}

Domain rules can be defined in \texttt{NDDL} in the context of a
predicate or an action. In the example above we can see the main
elements of a rule definition:

\begin{description}

\item[\textbf{Variables}]: A token type (predicate or action) is part
  of a class, therefore class attributes (see \texttt{object.location}
  above), token type parameters (see \texttt{[from, to]} in
  \texttt{Agent::Go}, or \texttt{[duration, product]} in
  \texttt{Agent::Buy}) and locally declared variables (see
  \texttt{possibleStores} in \texttt{Agent::Buy}) can all be used in
  the definition of a rule.

\item[\textbf{Constraints}]: Restrictions on values that variables can
  take within a rule are expressed through constraints. In the example
  above the \texttt{eq} constraint is used; in general, any constraint
  available in \eus library can be used.

\item[\textbf{Subgoals}]: In \texttt{Agent::Go}, subgoals are used to
  specify that the Shopping Agent's location must transition from
  origin to destination in a temporally consistent way. The
  \texttt{[meets, equals, metby]} operators (see Section
  \ref{sec:europa:inference}) are used to specify subgoals, along with
  the temporal relationship each token representing a subgoal has with
  the the token representing the \texttt{Agent::Go} action. Also,
  \texttt{[condition, effect]} annotations can be used when defining a
  subgoal inside an action. Currently \eu does not associate semantics
  with these annotation; but they can be extremely useful for search
  modules when creating plans.

\end{description}

With that specification for the Shopping Agent domain, a particular
problem instance could be stated as follows:

\begin{verbatim}

// Allocate instances
Location Home = new Location("Home");
Location SuperMarket = new Location("SuperMarket");
Location HardwareStore = new Location("HardwareStore");

Product Banana = new Product("Banana");
Product Milk = new Product("Milk");
Product Drill = new Product("Drill");

ProductLocation bananaLocation = new ProductLocation(SuperMarket, Banana);
ProductLocation milkLocation = new ProductLocation(SuperMarket, Milk);
ProductLocation drillLocation = new ProductLocation(HardwareStore, Drill);

Agent agent = new Agent();

// Indicate that the database is closed - no new objects can be created
// this allows EUROPA to perform more efficient inference
close();

// We start the day at Home:
fact(agent.location.At atHomeForBreakfast);
atHomeForBreakfast.loc.specify(Home);

// Goals for all of the agent's needs, buy if needed
goal(agent.Own gotMilk);
gotMilk.product.specify(Milk);
goal(agent.Own gotBanana);
gotBanana.product.specify(Banana);
goal(agent.Own gotDrill);
gotDrill.product.specify(Drill);

// Make sure agent is home for dinner
goal(agent.location.At atHomeForDinner);
atHomeForDinner.loc.specify(Home);

// Agent has all day to satisfy goals:
gotMilk after atHomeForBreakfast;
gotMilk before atHomeForDinner;

gotBanana after atHomeForBreakfast;
gotBanana before atHomeForDinner;

gotDrill after atHomeForBreakfast;
gotDrill before atHomeForDinner;

// Force things to happen within our planning horizon:
int horizonStart = 0;
int horizonEnd = 100;
leq(horizonStart, atHomeForBreakfast.start);
leq(atHomeForDinner.end, horizonEnd);

\label{eu:model}
\end{verbatim}

This problem instance consists of \textbf{Variables} and
\textbf{Objects}, \textbf{Facts}, \textbf{Goals} and
\textbf{Constraints}. In our example we define temporal variables that
are used to specify the planning horizon (\texttt{horizonStart} and
\texttt{horizonEnd}) and objects are used to specify locations,
products, product-location associations and the Shopping Agent that we
want to plan for. Facts are used to specify the current state of the
world and do not need any support and are represented as tokens in
\eus plan database. In this case we use facts to specify that the
Shipping Agent is initially at home. Goals are also represented as
tokens in \eus plan database. Different from facts, goals trigger
inference in \eu which determines whether flaws (unresolved subgoals,
overloaded resources, etc.) need to be resolved; if so, search modules
can be invoked to resolve those flaws as part of the deliberation
process. Finally, constraints are restrictions on and between actions
and goals. In the example above, we use temporal constraints to
specify when facts hold and when the goals should be
accomplished. % As
% always, all constraints in \eus library could be used.


\subsection{Automated Inference}
\label{sec:europa:inference}

In \eue, all variables and constraints from a problem domain
description are stored inside the \texttt{CRE}.  The \texttt{CRE}
provides a framework where any number of constraint types can
collaborate to perform inference and prune variable domains using
Bounds Propagation and Domain Reduction techniques \kcomment{citation
  needed}. \eu uses a Propagator pattern which keeps track of a set of
constraint instances of the same type and is responsible for ensuring
that whenever any variable is modified or constraints are introduced
or dropped, all related variables are updated through inference.

In a planning problem, variable or constraint changes can come
directly from an end user (by introducing new activities or goals and
relating them to the rest of the plan through constraints, by changing
the start time of an activity, etc), or can come from an automated
planner (by expanding subgoals, introducing precedence constraints to
resolve mutual exclusion conflicts, etc). When these changes happen,
each Propagator is only able to ensure consistency for the constraints
that are associated with it.  To maintain global consistency, the
\texttt{CRE} implements a variant of the \texttt{AC-3} algorithm
\cite{mackworth77} where it asks Propagators to perform inference
until the Constraint Network returns to an stable state.

\input{constraints-table}

A \eu user can introduce new constraint types by implementing
specialized Constraint and Propagator classes in C++, however, \eu
provides a built-in Constraint Library with over 25 arithmetic, temporal, set and
resource constraint types so that a large number of problem domains
can be modeled without having to introduce new constraint
types. Tables \ref{tab:calconst}, \ref{tab:setconst},
\ref{tab:objhierarchy} and \ref{tab:misc} show various constraint
types.

Temporal and resource constraints are specially important to model
real-life planning domains, so it is worth going into some more detail
about how \eus built-in support works for those constraint types.

\textit{Temporal Constraints:} \eu uses variables to explicitly
represent timepoints for plan activities and states. Constraints among
timepoints provide a natural way to express domain axioms. For
example, in order to state that activity $A$ must occur before
activity $B$ we can say that the end timepoint of $A$ is $leq$ the
start timepoint of $B$.

\begin{figure}
\centering
\includegraphics[scale=0.3]{figs/Allen-algebra.pdf}
\caption{\small Temporal relations defined within the planner are
  based on \texttt{Allen Algebra} relations shown above.}
\label{fig:allen-algebra}
\vskip-0.3cm
\end{figure}

\cite{dechter91} proposed that constraints among timepoints can be
grouped together to form a Simple Temporal Network (STN). Such a
network can be transformed into a Distance Graph (DG) where the
outward arc from a node represents the maximum distance from the
source node to the target node.  The diagram below illustrates a
simple STN with just 2 variables and a single constraint. It also
shows the resulting DG.

reflected by the use of the \texttt{Allen Algebra} \cite{allen84}
temporal relations shown in Fig. \ref{fig:allen-algebra}. Interval
arithmetic in the EUROPA$_2$ domain model using \texttt{Allen Algebra}
allows encoding of temporal constraint relationships between tokens on
concurrent timelines. See \cite{jonsson00} for additional details
including propagation algorithms and interval logic.


\begin{figure}[!htb]
  \centering
  \subfloat[\small A Simple Temporal Network (STN)]{\label{fig:stn1}\includegraphics[width=0.4\columnwidth]{figs/stn-graph.pdf}}
  \subfloat[\small Resulting distance graph from \ref{fig:stn1}.]{\label{fig:stn2}\includegraphics[width=0.4\columnwidth]{figs/distance-graph.pdf}}
    \caption{\small An illustration of a STN and its corresponding
      distance graph.}
  \label{fig:stn}
\end{figure}

\cite{dechter91} also showed that shortest path algorithms could be
used to propagate values in the network and discover a negative
cycle. A negative cycle is a path from a node to itself that has a
path length less than 0. If such a cycle exists, the network is
inconsistent. It was further shown that a single-source shortest path
algorithm was sufficient to detect a negative cycle and provide
sufficient propagation to yield a backtrack-free search. Thus we have
an efficient and complete algorithm for propagating an STN. \eus
Propagator for temporal constraints is a straight implementation of
this algorithm.

\textit{Resource Constraints:} Most real life planning problems have
to deal with the fact that plans made up of actions that require
resources to be performed typically have only a limited amount of
those resources available (think of fuel, storage capacity, etc).  \eu
provides built-in support for resources whose availability can be
measured with real numbers, in terms of \eus representation, resource
object types and their related constraints are provided as follows:

\begin{enumerate}

\item \textbf{Reservoir} resources can have both
  \texttt{consume(resource,time,quantity)} and
  \texttt{produce(resource,time,quantity)} constraints. Production and
  consumption is instantaneous (it happens at a single point in time)

\item \textbf{Reusable} resources have
  \texttt{uses(resource,start,duration,quantity)} constraints that use
  a quantity of the resource for a specific duration, then release it.

\item \textbf {Unary} resources are Reusable resources with
  capacity=1, which allows \eu to perform some run time savings
  compared to the generic Reusable class.

\end{enumerate}

\eu offers configuration options so that in addition to the usual
constraint violations when a resource is completely depleted, plan
flaws can be generated whenever a resource level is outside a specific
upper or lower limit, or when instantaneous production or consumption
exceeds a specific threshold.

Recall that \eu supports a flexible temporal representation, where
time is represented by intervals, instead of single values. In this
context, determining whether a resource is the source of a plan flaw
or a constraint violation in general is more difficult than just
computing a profile of the resource and checking against some limits.
In the context of time flexibility, there are many resource profiles
that are possible, depending on when exactly each
production/consumption event happens out of all the possible values
that are in the domain of the variables that represent the time for
the event.  \cite{mus02} proposed an algorithm where the variables
that represent the time for production/consumption events are placed
in a temporal network, similar to the network used by the Temporal
Propagator above, then the constraints on the resource can be seen as
quantities flowing through that network. Computing the maximum flow
will yield the maximum resource usage, and thus a lower bound on the
resource level, and computing a minimum flow will similarly yield an
upper bound. Since maximum flow on a temporal network can be computed
in polynomial time, \eu takes advantage of this algorithm to
efficiently compute upper and lower bound envelopes on the resource
level.

\begin{figure}
\centering
\includegraphics[scale=0.2]{figs/europa-resource-envelopes.png}
\caption{\small Resource Envelopes computed by  \eu}
\label{fig:resenvelopes}
\vskip+0.1cm
\end{figure}

Resource envelopes can be very useful when trying to figure how
brittle a plan in the face of changing activity durations or start
times. They can also be useful when searching for plans, although they
are relatively expensive to compute so their ability to prune the
search space must be weighted against the ability to search faster
\cite{6007772}.


\subsection{Search in \eu}
\label{sec:europa:search}

Given the above elements, an automated problem solver can be
created using:

\begin{enumerate}

\item A domain model that describes the variable, object, predicate
  and action types that are relevant for the problem.

\item A problem instance (also called initial state) that consists of:

    \begin{enumerate}

    \item Variable and Object instances that exist for the entire
      planning horizon.

    \item Temporally scoped predicate and action instances.

    \item Temporally scoped goals.

\end{enumerate}

\end{enumerate}
	
This information is kept in \eus Plan Database so that inference and
search mechanisms can be used to look for a problem solution.

Given that temporal intervals may extend indefinitely in both positive
and negative directions, for problems with a temporal dimension it is
also common to specify a Planning Horizon when invoking a solver. The
Planning Horizon is the temporal interval that a problem solver has to
worry about, any decisions that fall completely outside of the
Planning Horizon can be ignored. This is very useful for recurrent
activities, consider for instance a model where a medical checkup has
to occur every 3 months, the user can model a recurring activity and
then use the Planning Horizon to ensure that a finite number of
medical checkup activities are generated as part of a plan. This is
also useful to ignore activities that may happen too far in the future
or in the past to be relevant for a particular plan, this way the user
can ensure that the solver is making as few commitments as necessary.

\eu provides a built-in solver that performs Plan Space Planning
\cite{ghallab04} in this approach, the initial state is considered a
partial plan that needs to be refined toward a solution plan that
achieves the goals. The operations to refine the partial plan PP at
any time are:

\begin{enumerate}

\item Find the flaws of PP, that is the conditions that prevent it
  from being a solution plan (flaw types are explained below).

\item Select one such flaw

\item Select a resolver for the flaw

\item Refine PP by applying the resolver

\item If an inconsistency is found, try another resolver.

\item If all possible resolvers for a particular flaw fail, return
  failure, otherwise continue until resolving all the flaws.

\end{enumerate}
	
This Plan Space Planning algorithm is translated into \eus
representation as follows:

The initial partial plan is the state of \eus Plan Database after the
initial state has been instantiated, this results in a set of
variable, object and token instances. Inference then takes place to
detect flaws in the partial plan, there are 3 kinds of flaws that can
be detected:

\begin{enumerate}

\item Unbound Variable: a variable in the partial plan whose domain is
  not a singleton. Unbound Variables are resolved by specification of
  a value from the domain of the variable.

\item Open Condition: an open condition is an inactive token. Inactive
  tokens can be generated by explicitly posted goals, or when a token
  is activated, rules may fire that create inactive slave tokens as
  described in section \comment{point to EUROPA Plan Representation
    section}.  Open Conditions can be resolved in three ways:

  \begin{enumerate}

  \item Merging: A free activity is merged with a matching activity
    already in the plan. An activity a is said to match an activity a?
    if a and a? unify and the temporal constraints involving a are
    satisÞed by a?. Thus, a and a? can be considered the same activity
    and we do not need to introduce a in the plan. Consequently, the
    compatibilities associated with a are not Þred, because they have
    been already triggered when a? was introduced in the plan.

  \item Activation: We introduce a new activity a in the current plan
    associating it with the proper timeline, but without choosing a
    speciÞc time slot for it.The compatibilities associated with a are
    applied and the subgoal activities resulting from those
    compatibilities are introduced as free activities. This results in
    both an ordering flaw, corresponding to the just activated
    activity, and a number of open condition flaws, corresponding to
    the new subgoal activities.

  \item Rejection: Some goals may be optional, if that is the case for
    a particular order condition, its corresponding flaw can be
    resolved by discarding the inactive token.

\end{enumerate}

\item Threat: once a token has been placed in the partial plan it may
  impact other tokens indirectly through possible overlapping
  requirements on objects. Recall for example that a token may belong
  to objects (e.g. Timelines) which require a total order over their
  tokens. If any 2 tokens could possibly overlap (though not
  necessarily), then they pose a threat to each other in terms of
  achieving an extension of the current partial plan which is complete
  and consistent. Similarly, threats may arise where tokens share a
  common resource and their current state might yield extensions of
  the current partial plan which are inconsistent. Threats are
  resolved by imposing ordering constraints among tokens.

\end{enumerate}

Open Conditions and Threats allow flaw detection and resolution at a
higher-level of abstraction (i.e. in terms of objects and tokens) than
that of simply binding variables as is common in Constraint
Satisfaction Problems. This is advantageous when one applies
heuristics for ordering choices since it provides a richer context in
which to make decisions.  Furthermore, it aids in reducing the amount
of work done by a solver so that only the necessary refinements are
made, otherwise leaving the partial plan with maximum flexibility. For
example, one can omit unbound variables which are time-points of
tokens since threats will force a solver to impose restrictions on
these variables based on the semantics of the objects to which their
tokens apply. Thus the planning process may yield partially-ordered
plans for which all possible extensions are provably valid.

The Plan Space Planning algorithm described above can be implemented
in many different ways depending on the approach chosen for flaw and
resolver selection and for backtracking. \eus built-in solver
implements a chronological backtracking algorithm that is summarized
in Algorithm \ref{alg:europa:solve}.


\begin{algorithm}[H]
\KwIn{PartialPlan $plan$}
\KwOut{\texttt{true} if a plan solution was found, \texttt{false} otherwise}
\Begin{
  \lIf{isInconsistent(plan)}{\Return \texttt{false}\;}\label{li:propagate}
  \BlankLine
  Flaw $flaw \leftarrow chooseFlaw(plan)$ \; \label{li:selectflaw}
  \lIf{ $\emptyset = flaw$ }{\Return \texttt{true} \;} \label{li:noflaw}
  \BlankLine
  DecisionPoint $decision \leftarrow makeDecisionPoint(flaw, plan)$ \; \label{li:decisionpt}
  \While{ $decision.hasNext()$ }{ \label{li:decisionloop}
    PartialPlan $pp \leftarrow decision.executeNext()$ \; \label{li:decide}
    \lIf{ $solve(pp)$ }{ \Return \texttt{true} \; } \label{li:recurse}
    \lElse{ $decision.undo()$ \; } \label{li:backtrack}
   }
   \Return \texttt{false} \; \label{li:noplan}
 }
\caption{$\mathrm{bool} ~ solve(plan)$}
\label{alg:europa:solve}
\end{algorithm}


The algorithm takes as input a partial plan p and returns true if a
complete and consistent refinement of p could be found (or if p is
initially complete and consistent), and false otherwise.

\begin{enumerate}

\item Line \ref{li:propagate}: Propagate the constraints to test for
  inconsistency. If found to be inconsistent, then we can return false
  since this is a dead-end i.e. no refinements to p can yield a
  consistent plan.

\item Line \ref{li:selectflaw}: Choose a flaw from the set of
  available flaws.

\item Line \ref{li:noflaw}: If there are no flaws, then p is complete
  and we can terminate with success.

\item Line \ref{li:decisionpt}: Otherwise we formulate a decision
  point which is a branch in the search space. Each choice is a
  particular refinement operation and the DecisionPoint collects all
  possible refinement operations for the given flaw.

\item Line \ref{li:decisionloop}: We keep trying until the chosen flaw
  is resolved, or until we run out of resolvers to try.

\item Line \ref{li:decide}: A new partial plan is obtained by
  application of a refinement operator. Note that the ordering over
  refinement operators to select is a non-deterministic step.

\item Line \ref{li:recurse}: Recursive call to solve the new planning
  problem. If successful, then we are done.

\item Line \ref{li:backtrack}: Otherwise, retract the last refinement
  operation and move on to try the next one.

\item Line \ref{li:noplan}: If we arrive here, then we have exhausted
  all options to resolve the flaw, including the case where no options
  were available initially. Thus the problem cannot be solved.

\end{enumerate}


This algorithm provides for a sound and complete search, assuming that
no flaws or available refinement operators are pruned unnecessarily.
Dead-ends in the search are discovered through constraint propagation.
Constraint propagation is a vehicle for evaluating the consistency of
a partial plan and also for filtering infeasible values from
consideration prior to commitment, allowing in some cases a strong
look-ahead capability which is essential for tractable
search. Consistency testing is initiated by the isConsistent
procedure. The algorithm permits a heuristically controlled search by
applying orderings for chooseFlaw and makeDecisionPoint. It results in
a chronologically-backtracking search.

Heuristics can be implemented by applying ordering/filtering policies
for \texttt{chooseFlaw} and \texttt{makeDecisionPoint}, for instance,
by dealing with earliest flaws first, or by making planning decisions
(open condition flaws) before scheduling ones (threats), etc.

It should be emphasized that while this algorithm is commonly
employed, it is only one of many that could be implemented. As a
simple example, consider the following solver for the N-Queens
problem, where there is an integer variable Vi to represent the queen
in column i, so that for instance, V1=3 means that the variable on
column 1 is placed on row 3.  non-attack constraints are posted as
arithmetic constraints among the Vi variables to ensure that all the
rows and diagonals contain only one queen.

\begin{algorithm}[H]
  \KwIn{ConstraintEngine $ce$}
  \KwIn{int $maxIter$}
  \Begin{
    int $curIter \leftarrow 0$ \;
    \While{$\left( ce.getViolations() > 0 \right) ~ \& ~ \left( curIter <
        maxIter \right)$ }{
      Variable $queenToMove \leftarrow getQueenWithMaxViolation(ce)$
      \;
      SortedSet$<$int$> moves \leftarrow getMoves(ce, queenToMove,
      curPos)$ \;
      bool $moved \leftarrow $ \texttt{false} \;
      \ForEach{int $newPos$ of $moves$}{
        $moved \leftarrow tryMove(queenToMove, curPos, newPos)$\;
        \lIf{$moved$}{ \textbf{break} \; }
      }
      \lIf{$! moved$}{
        $forceMove(queenToMove, curPos, moves.first())$ \;
      }
      $checkSolution()$ \tcp*{See if we have a new best solution}
      $curIter$\texttt{++} \;
    }
  }
  \caption{$solveNQueens(ce, maxIter)$}
\end{algorithm}

\eus Constraint Reasoning Engine can be used to compute the non-attack
constraint violations (\texttt{ce.getViolations()} is a straight call
on the \eu API), to easily pick the queen that has he most violations
by implementing \texttt{getQueenWithMaxViolation(ce)} and to look
ahead and see what moves are possible for a queen that would remove
its violations by implementing
\texttt{getMoves(ce,queenToMove,curPos)}.

In similar fashion, the constraint violation and flaw reporting
mechanisms that \eu provides can be used as building blocks that
specialized or general purpose search algorithms can use to construct
plans.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "setobook"
%%% End: 


 