\section{EUROPA}
\label{sec:europa}

EUROPA is a general purpose AI planning toolkit developed at NASA Ames.  Automated Planning can be reformulated as a constraint satisfaction problem (TODO: ref). EUROPA is an extension of that idea, however, unlike other approaches where the entire planning problem is translated into a CSP and then solved using traditional CSP methods, EUROPA uses a constraint reasoning engine as a fundamental building block, and enriches it with other architectural components that allow a more direct mapping for scheduling and planning problems, which in turn allows easier development of efficient solving methods.

Let's look at some of the problems that can be tackled using EUROPA.

Constraint Satisfaction: 
In the N-Queens problem, chess queens must be placed on an NxN chessboard in a way that there are no queens attacking each other.

Below is an example of a random positioning of queens on a NxN chessboard. Queens in violation of the non-attack constraint are highlighted in red.
TODO: include figure.


If we define NxN variables Qrc, r E [1,N], c E[1,N] , 
Qrc = 1 if Cell r,c in he chessboard is occupied by a Queen, 0 otherwise.

then we have to satisfy the following constraints:
Sum(Qrc) = 1 ForAll r (Only one Queen per row)
Sum(Qrc) = 1 ForAll c (Only one Queen per column)

Sum(Qr+i,c+i) = 1
Sum(Qr-1,c+i) = 1 (only on Queen on each diagonal)

We can solve the problem by finding assignments for all variables Qrc that satisfy the constraints above. 

Below is a solution found by EUROPA using that formulation and a specialized search procedure.

TODO: include figure

Scheduling:
In the Resource Constrained Project Scheduling Problem (RCPSP), a project consisting of a set of activities must be scheduled in a way that satisfies minimum and/or maximum temporal separation constraints among them, as well as respects fixed limits on the availability of resources required to perform each activity. In addition to satisfying temporal and resource constraints, it is common for the user to want to minimize makespan so that the entire project is finished as early as possible.

Below is an example of a a solution provided by EUROPA for an RCPSP instance with 10 activities, 5 resources and 30 temporal constraints.
TODO: include figure

Planning:
In the Shopping Agent Problem (TODO: ref to Norvig) an agent needs to purchase a set of products that are available at specific locations (supermarket, hardware store, etc), the agent  is subject to temporal (must complete tasks by specific deadlines) and resource (fuel, carrying capacity, etc) constraints.

Below is a solution produced by EUROPA for a simple problem instance where the shopping agent needs to buy Bananas, Milk and a Drill.

TODO: include figure

As we can see, a planning problem (what actions must be performed to achieve a goal) may embed a scheduling problem (in what order should those actions be performed), and both embed Constraint Satisfaction problems as temporal, resource and many other kinds of constraints must be respected in most real life problems.

These relationships between Planning, Scheduling and Constraint Satisfaction have been examined in detail in the literature (TODOL ref Frank et al on Planning vs. Scheduling), and they lead to EUROPA's use of constraint reasoning as its innermost building block. Next we will examine the main ideas from Constraint Satisfaction Programming, and from Constraint Based Planning and Scheduling that constitute EUROPA's theoretical underpinnings, then we dive into how EUROPA implements those ideas.

\subsection{Constraint Programming}
\label{sec:europa:cp}

Constraint Satisfaction Programming, also know as Constraint Programming (CP) is a discipline that provides a generic framework for representing, solving and making logical inference on constraints. A complete treatment of this discipline is given in [MAR98] and [APT03] and very concise introductions are provided in [BAR99] and [LUS01]. 

	A constraint programming problem consists of a set of variables V={x1,..,xN}, where each variable takes values from a domain d1,..,dN. Domains are most often discrete and finite, but there are numerous CP implementations associated with continuous domains. Given a defined conjunctive set of constraints on the variables: $C=\{c1(x1,..,xN), ..., cK(x1,..,xN)\}$, the objective is to find one or more value assignments to V where all constraints are satisfied.

To solve a problem, CP uses logical inference to perform 2 operations:

\begin{enumerate}
	\item Bounds propagation: To infer upper and lower variable bounds. For example, from the constraints x1 + x2 <= 2, xi>=0, we can infer [0,2] bounds for x1 and x2

	\item Domain reduction: To infer a valid set of values for a variable. For example, for discrete variables, the constraints allDifferent(x1,x2,x3) and xi>=0, xi <=4. if x1 =1 and x2=3 we can infer that the valid domain for x3 is reduced to {2,4} 

\end{enumerate}

CP is normally implemented as part of a programming language and constraints are normally represented as objects [PUG95]. Any constraint can be introduced and, as long as the bounds propagation and domain reduction protocols specified by the host CP system are enforced, it will be indistinguishable from any other ÒprimitiveÓ CP constraint, such as <= or >=.

TODO: talk about arc consistency algorithms, computational complexity and solvers.


\subsection{Constraint-Based Attribute and Interval Planning}
\label{sec:europa:cp}

There has been 
State Variable representation

CSP encodings

Constraint Based and interval planning.

\subsection{EUROPA's Architecture}
\label{sec:europa:arch}

The following figure displays the main architectural components in EUROPA and their relationships:



(TODO: add figure)


\begin{enumerate}

	\item The Constraint Reasoning Engine (CRE): manages variables, the domains from which they can take values, and constraints that define relationships among variables. It also provides an efficient arc consistency mechanism (TODO: ref to AC-3). The CRE is designed so that specialized reasoning algorithms for specific constraints can be easily and efficiently plugged in.

	\item The Plan Database (PDB): manages object types and objects, which are a mechanism to group variables to more naturally model the real world in much the same way that object oriented programming does. Also manages tokens, which are a mechanism to group variables to represent temporally scoped state. Objects and tokens can be used to model planning domains in a much more natural and extensible way that a pure CSP approach can (TODO: provide snippet?)
	
	TODO: talk about the token network, move stuff from the Concepts section if necessary

	\item The Rules Engine (RE): manages causal dependencies in a planning model (TODO: explain)

	\item The language modules: NDDL, ANML, and other higher level modeling languages can me used to create domain models and problem instances (TODO: point advantages over pure programming API approaches, provide snippets)

	\item API Layer: makes all the services available so that EUROPA can be used to build applications.

	\item Extension Modules bundled with EUROPA: Temporal Network, Resources, NDDL, ANML.
		\begin{enumerate}
			\item Temporal Network
			\item Resources
			\item NDDL
			\item ANML (TODO:maybe it's better to leave out?)
		\end{enumerate}

\end{enumerate}


\subsection{Modeling}
\label{sec:europa:modeling}

Shopping model:

\begin{verbatim}

// Locations (Home, SuperMarket, etc.)
class Location {
  string name;
  Location(string _name){
    name = _name;
  }
}

// Products (Milk, Banana, etc.) and
class Product {
  string name;
  Product(string _name) {
    name = _name;
  }
}

// ProductLocations (Banana can be found at SuperMarket, for example)
class ProductLocation {
  Location location;
  Product product;

  ProductLocation(Location _location, Product _product){
    location = _location;
    product = _product;
  }
}

// Use built-in Timeline functionality to enforce that an agent:
// a) Can't be at more than one place at a time.
// b) Can't Go more than one place at a time.
// c) Can't Go somewhere and be At somewhere at the same time.
class AgentLocation extends Timeline{
  predicate At {
    Location loc;
  }

  predicate Going {
    Location from;
    Location to;
  }
}

// In addition to having a location timeline, the agent can buy and own things.  
// Note that the actions and the location predicates can be concurrent 
// so they can't be on the same Timeline
class Agent {
  AgentLocation location;

  Agent() {
    location = new AgentLocation();
  }

  action Buy {
    Product product;
  }
  
  action Go {
    Location from;
    Location to;
  }
  
  predicate Own {
  	Product product;
  }
}


// Define the rules for our actions:
Agent::Go {
  met_by(condition object.location.At origin);
  eq(from, origin.loc);
 
  equals(effect object.location.Going going);
  eq(going.from, from);
  eq(going.to, to);
   
  meets(effect object.location.At destination);
  eq(to, destination.loc);
}

Agent::Buy {
  // A Buy takes 10 time units
  eq(10, duration);

  // initialized to all locations
  ProductLocation possibleStores;

  // limit possibleStores variables to ones that provide what we need to buy
  eq(product, possibleStores.product);

  // We must be At a location during our Buy, and that location must have the
  // product we want available:
  contained_by(condition object.location.At currLocation);
  eq(currLocation.loc, possibleStores.location);
  
  starts(effect Own purchase);
  eq(purchase.product,product);
}

\end{verbatim}


And a problem instance:

\begin{verbatim}

// Allocate instances
Location Home = new Location("Home");
Location SuperMarket = new Location("SuperMarket");
Location HardwareStore = new Location("HardwareStore");

Product Banana = new Product("Banana");
Product Milk = new Product("Milk");
Product Drill = new Product("Drill");

ProductLocation bananaLocation = new ProductLocation(SuperMarket, Banana);
ProductLocation milkLocation = new ProductLocation(SuperMarket, Milk);
ProductLocation drillLocation = new ProductLocation(HardwareStore, Drill);

Agent agent = new Agent();

// Indicate that the database is closed - no new objects can be created
close();

// We start the day at Home:
fact(agent.location.At atHomeForBreakfast);
atHomeForBreakfast.loc.specify(Home);

// Goals for all of the agent's needs, buy if needed
goal(agent.Own gotMilk);
gotMilk.product.specify(Milk);
goal(agent.Own gotBanana);
gotBanana.product.specify(Banana);
goal(agent.Own gotDrill);
gotDrill.product.specify(Drill);

// Make sure agent is home for dinner
goal(agent.location.At atHomeForDinner);
atHomeForDinner.loc.specify(Home);

// Agent has all day to satisfy goals:
gotMilk after atHomeForBreakfast;
gotMilk before atHomeForDinner;

gotBanana after atHomeForBreakfast;
gotBanana before atHomeForDinner;

gotDrill after atHomeForBreakfast;
gotDrill before atHomeForDinner;

// Force things to happen within our planning horizon:
int horizonStart = 0;
int horizonEnd = 100;
leq(horizonStart, atHomeForBreakfast.start);
leq(atHomeForDinner.end, horizonEnd);

\end{verbatim}

TODO: introduce model for Shopping link to architectural components.
explain variable, object, predicate and action types and instances, constraints, goals and facts.

\subsection{Inference}
\label{sec:europa:inference}

TODO: explain how inference is used to detect perform bounds propagation, domain reduction and to detect constraint violations.
- talk about AC3 implementation and extension mechanisms
- talk about europa's constraint library
- talk about Temporal Network
- talk about Resource Envelopes.

\subsection{Search}
\label{sec:europa:search}

Now we have all the elements in place so that an automated problem solver can be created. Let's recap what those elements are:

\begin{enumerate}

\item A domain model that describes the variable, object, predicate and action types that are relevant for the problem.
\item A problem instance (also called initial state) that consists of:
	\item Variable and Object instances that exist for the entire planning horizon.
	\item Temporally scoped predicate and action instances.
	\item Temporally scoped goals.

\end{enumerate}
	
All this information is kept in EUROPA's  Plan Database so that inference and search mechanisms can be used to look for a problem solution.

Given that temporal intervals may extend indefinitely in both positive and negative directions, for problems with a temporal dimension it is also common to specify a Planning Horizon when invoking a solver. The Planning Horizon is the temporal interval that a problem solver has to worry about, any decisions that fall completely outside of the Planning Horizon can be ignored. This is very useful for recurrent activities, consider for instance a model where a medical checkup has to occur every 3 months, the user can model a recurring activity and then use the Planning Horizon to ensure that a finite number of medical checkup activities are generated as part of a plan. This is also useful to ignore activities that may happen too far in the future or in the past to be relevant for a particular plan, this way the user can ensure that the solver is making as few commitments as necessary.

EUROPA provides a built-in solver that performs Plan Space Planning (TODO: ref), in this approach, the initial state is considered a partial plan that needs to be refined toward a solution plan that achieves the goals. The operations to refine the partial plan PP at any time are:
\begin{enumerate}
	\item Find the flaws of PP, that is the conditions that prevent it from being a solution plan (flaw types are explained below).
	\item Select one such flaw
	\item Select a resolver for the flaw
	\item Refine PP by applying the resolver
	\item If an inconsistency is found, try another resolver.
	\item If all possible resolvers for a particular flaw fail, return failure, otherwise continue until resolving all the flaws.
\end{enumerate}
	
This Plan Space Planning algorithm is translated into EUROPA's representation as follows:

The initial partial plan is the state of EUROPA's Plan Database after the initial state has been instantiated, this results in a set of variable, object and token instances. Inference then takes place to detect flaws in the partial plan, there are 3 kinds of flaws that can be detected:

\begin{enumerate}
	\item Unbound Variable: a variable in the partial plan whose domain is not a singleton. Unbound Variables are resolved by specification of a value from the domain of the variable.

	\item Open Condition: an open condition is an inactive token. Inactive tokens can be generated by explicitly posted goals, or when a token is activated, rules may fire that create inactive slave tokens (TODO: point to more detailed decription above in Rules Engine section).  Open Conditions can be resolved in three ways: 
\begin{enumerate}
		\item Merging: A free activity is merged with a matching activity already in the plan. An activity a is said to match an activity a? if a and a? unify and the temporal constraints involving a are satisÞed by a?. Thus,  a and a? can be considered the same activity and we do not need to introduce a in the plan. Consequently, the compatibilities associated with a are not Þred, because they have been already triggered when a? was introduced in the plan. 
		\item Activation: We introduce a new activity a in the current plan associating it with the proper timeline, but without choosing a speciÞc time slot for it.The compatibilities associated with a are applied and the subgoal activities resulting from those compatibilities are introduced as free activities. This results in both an ordering ßaw, corresponding to the just activated activity, and a number of open condition ßaws, corresponding to the new subgoal activities. 
		\item Rejection: Some goals may be optional, if that is the case for a particular order condition, its corresponding flaw can be resolved by discarding the inactive token.
\end{enumerate}

	\item Threat: once a token has been placed in the partial plan it may impact other tokens indirectly through possible overlapping requirements on objects. Recall for example that a token may belong to objects (e.g. Timelines) which require a total order over their tokens. If any 2 tokens could possibly overlap (though not necessarily), then they pose a threat to each other in terms of achieving an extension of the current partial plan which is complete and consistent. Similarly, threats may arise where tokens share a common resource and their current state might yield extensions of the current partial plan which are inconsistent. Threats are resolved by imposing ordering constraints among tokens. 

\end{enumerate}

Open Conditions and Threats allow flaw detection and resolution at a higher-level of abstraction (i.e. in terms of objects and tokens) than that of simply binding variables as is common in Constraint Satisfaction Problems. This is advantageous when one applies heuristics for ordering choices since it provides a richer context in which to make decisions. Furthermore, it aids in reducing the amount of work done by a solver so that only the necessary refinements are made, otherwise leaving the partial plan with maximum flexibility. For example, one can omit unbound variables which are time-points of tokens since threats will force a solver to impose restrictions on these variables based on the semantics of the objects to which their tokens apply. Thus the planning process may yield partially-ordered plans for which all possible extensions are provably valid. 

The Plan Space Planning algorithm described above can be implemented in many different ways depending on the approach chosen for flaw and resolver selection and for backtracking. EUROPA's built-in solver implements a chronological backtracking algorithm that is summarized in the figure below.

\begin{verbatim}

01.  bool solve(PartialPlan plan)
02.   {
03.      if (isInconsistent(plan))  return false;
04.
05.      Flaw flaw = chooseFlaw(plan);
06.      if (flaw == NULL) return true;
07.
08.      DecisionPoint decision = makeDecisionPoint(flaw, plan);
09.
10.      while(decision.hasNext()) {
11.          PartialPlan pp = decision.executeNext();
12.
13.          if (solve(pp)) return true;
14.          else d.undo();
25.      }
16.
17.      return false;
18.  }

\end{verbatim}

The algorithm takes as input a partial plan p and returns true if a complete and consistent refinement of p could be found (or if p is initially complete and consistent), and false otherwise. 

\begin{enumerate}
	\item Line 3: Propagate the constraints to test for inconsistency. If found to be inconsistent, then we can return false since this is a dead-end i.e. no refinements to p can yield a consistent plan.
	\item Line 5: Choose a flaw from the set of available flaws.
	\item Line 6: If there are no flaws, then p is complete and we can terminate with success.
	\item Line 8: Otherwise we formulate a decision point which is a branch in the search space. Each choice is a particular refinement operation and the DecisionPoint collects all possible refinement operations for the given flaw.
	\item Line 10: We keep trying until the chosen flaw is resolved, or until we run out of resolvers to try.
	\item Line 11: A new partial plan is obtained by application of a refinement operator. Note that the ordering over refinement operators to select is a non-deterministic step.
	\item Line 13: Recursive call to solve the new planning problem. If successful, then we are done.
	\item Line 14: Otherwise, retract the last refinement operation and move on to try the next one.
	\item Line 17:  If we arrive here, then we have exhausted all options to resolve the flaw, including the case where no options were available initially. Thus the problem cannot be solved.
\end{enumerate}

This algorithm provides for a sound and complete search, assuming that no flaws or available refinement operators are pruned unnecessarily. Dead-ends in the search are discovered through constraint propagation. Constraint propagation is a vehicle for evaluating the consistency of a partial plan and also for filtering infeasible values from consideration prior to commitment, allowing in some cases a strong look-ahead capability which is essential for tractable search. Consistency testing is initiated by the isConsistent procedure. The algorithm permits a heuristically controlled search by applying orderings for chooseFlaw and makeDecisionPoint. It results in a chronologically-backtracking, search. 

TODO: expand a little more on how heuristics can be implemented by applying ordering/filtering for chooseFlaw and makeDecisionPoint
examples:
- deal with earliest flaws first
- deal with planning (open condition flaws) before scheduling (threats) ones

It should be emphasized that while this algorithm is commonly employed, it is only one of many that could be implemented. TODO: give examples of local search solvers for scheduling and CSP?


TODO: 
- explain how other solvers can be built, maybe use NQueens or RCPSP example to illustrate. Or maybe build a little specialized solver for shopping or rover examples.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "setobook"
%%% End: 


 