\section{Planning and execution in the \texttt{T-REX} architecture}
\label{sec:arch}

\subsection{The T-REX architecture}
\label{sec:arch:trex}

% {\em\tiny This section introduces shortly T-REX architecture but move
%   quickly the focus on a single reactor and gross concepts on the
%   architecture:
%   \begin{itemize}
%   \item For t-trex the whole decision and control problem is reduced
%     around the state variables (or timeline construct). 
%   \item This reduce the execution tracking problem for each reactor on a state
%     identification problem (deduce internal state from the external
%     state), and the control problem to goal posting which will trigger
%     deliberation on the owner of the corresponding timeline. 
%   \item the architecture itself see each reactor as a black box and
%     therefore each reactor can implement its own mechanism in order to
%     resolve both synchronization and deliberation. Still we provide a
%     reactor based on the europa framework that leverage the automated
%     planning capabilities in order to do model based planning and
%     execution with a rich representation of resources and time.
%   \end{itemize}}
 
The T-REX architecture was designed with the objective to bring 
planning closer to the low-level control of the vehicle while
maintaining its reactivity. Indeed, in most of the architecture where
task planning is embedded, this task remains at a failry high level of
abstraction as the complexity of this task would otherwise impede the
system reactiveness. As a result the planning problem managed {\em in
  situ} remains fairly detached from low-level control and most of the 
reactive adaptation which in contrast is managed by specialized 
component that relies on different representations for modeling 
the local behavior they control or even do not have any explicit 
formal model of this behavior. Taking cues from the IDEA 
architecture \cite{mus02}, we designed a core framework that provides a
formal basis \cite{Py:2010ti} on the way each of the sub-component --
called reactors -- of our agent can interact by exchanging only
information through {\em state variables} by ensuring that state 
information can propagate through all the reactors ensuring a
consistent view of the present state of the world at every single tick
trough a bottom-up {\em synchronization} flow and collaboration for
future state evolution by timely exchanges of goals on {\em state
  variables}. This exchange does not impose to any reactor to be aware
of the reactors it is connected to but only focus on the state
variables it relies on (called {\em external}) and the state
variables it manages and maintains (called {\em internal}). 

Take for example the T-REX agent instance we use in our AUV
(Fig. \ref{fig:agent}). In this architecture all the reactors
(symbolized by colored boxes) do not have explicit connection from one
to another but instead rely on a publish/subscribe model on state
variables. For Example the \textsf{Pilot} reactor needs the {\em
  externally} managed state informations from \textsf{Sensor\_Data} 
and \textsf{Nav\_cmd} states variables in order to maintain {\em
  internally} the state variables \textsf{Waypoint} and
\textsf{Nav\_policy}. This relation applies in two way :
\begin{itemize}
\item In order to identify its current {\em internal} state values
  this reactor needs to know the current {\em external} state
  information it relies on. In this case the current \textsf{Waypoint}
  the vehicle is heading to can be extracted for example from the
  current \textsf{Nav\_cmd} executed.
\item The future objectives a reactor has on its future \textsf{Internal}
  state will probably imply sub-objectives to be reported to the
  owner of its {\em external} depending on their current values. Again
  if this reactor wants to go ato a specific \textsf{Waypoint} --
  depending on its current position provided by \textsf{Sensor\_Data}
  it can identify a sequence of \textsf{Nav\_cmd} that should
  eventually help him reach this location.
\end{itemize}

\begin{figure}[!htb]
 \centering
 \includegraphics[scale=0.45]{figs/AUV-agent.pdf}
 \caption{\small A \texttt{T-REX} agent is composed of multiple
   reactors or control loops (rounded boxes) which are connected
   through state variables provided by one reactor ({\color{blue}blue}
   solid line) with multiple possible clients ({\color{green}green}
   dashed lines)}
  \label{fig:agent}
\end{figure}

Overal T-REX architecture helps to abstract to the reactor interaction
to only state variables. Each reactor is practically ignoring where
its {\em external} state information is managed as long as this
information is available and properly maintained so they can properly 
manage their own {\em internal} state information which in turn may be
used by other reactors. Such formalism also constrain reactors
interaction to state information exchanges which are two folds:
\begin{itemize}
\item {\em Observation on the current state values}: This information
  propagates up in the reactor graph at the synchronization phase 
  and occur at the beginning of every time steps (called
  ticks). During this phase the agent provides to each reactor 
  updates on their {\em external} state variables for this tick and
  ask them to compute their {\em internal} state variables values for
  this same tick. By doing so we propagate a consistent view of that
  state of the world throughout all the reactors as time advance.
\item {\em Goals request on future state}: This information propagates
  down in the reactor graph. It reflects that, in order to satisfy own
  of its {\em internal} objectives, a reactor may have a plan that
  rely on future values of one of its {\em external} state. When such
  a plan is identified we ensure that this part of the plan is given
  as a goal to the owner of the given {\em external(s)} state variable(s). 
\end{itemize}

{\em\color{red} Following is an attempt to present TREX as a big
  deliberation machine}
The overall execution cycle of the agent is also abstracted as some
continuous planning/deliberation cycle between all the
reactors. Indeed , at the agent interface level, each reactor provided
only two abstract calls that conceptualize their execution:
\begin{itemize}
\item \texttt{synchronize} that takes the last {\em external}
  observations as argument and will return the {\em internal}
  observations for this reactor or a failure report.
\item \texttt{step} that accept new goals requested (if any) on the
  {\em internal} timeline of this reactor and will execute one step of
  deliberation. The returned value indicates if a complete plan has
  been found and in that case will also provide the part of this plan
  applied to {\em external} timelines of this reactor.
\end{itemize}
Both of these two deliberative functions have different scope and
temporal constraints. The \texttt{synchronize} call is considered as
atomic and will focus only on state inference from the current tick by
identifying the current value of the {\em internal} state variables
from the latest updates on the {\em external} variables. This process
will then propagate up in the reactor graph at any single tick to
ensure that all reactors are aware of the current state of the
world. \texttt{step} relates to a single decision step of the planning
process which is focused on the future evolution of the state
variables and it can take multiple steps spanning other multiple
ticks for a reactor to produce a plan that is both complete and
valid. when such plan is identified its {\em external} part is then
dispatched to the corresponding reactors which in turn can start their
deliberation \texttt{step}s in order to satisfy these new
objectives. as a consequence physical execution will occur as these
goals and planning propagate down in the reactor graph until they
eventually become goals for the lowest level reactor which -- instead
of deliberating -- may just transform this goal in a physical command
execution. 
{\em\color{red} end of the attempt; need to rework the paragraphs
  below accordingly}

The overal execution cycle of the agent is emerging through these
interaction and the processing that occurs in each reactors in order
to process them. New observation occurring at every tick inform each
reactor of the current state of the world and impose them to identify
how it impact their state (and potentially what they planned for the
future). Goals they receive will trigger in the reactor the need to
identify a strategy (or plan) that will allow them to reach these new
states knowing their current state deduced from synchronization.When
such a plan has been identified, the {\em external}  part is then
dispatched to other reactors that can do the same. This flow and focus
around state and goals is perfectly fitting with automated planning
and even more so to the Europa framework. As an illustration, in 
 Fig. \ref{fig:agent}, only \textsf{Shore comm.} and \textsf{Vehicle}
 reactors are specialized C++ code (acting as interface to external
 programs). All the other reactors are based on the europa framework
 differentiated only by the domain model they manipulate and som
 heuristic configuration parameters. In the following sections we are
 going to focus specifically ion this kind of reactor to illustrate
 how  a formal planning framework can be used in our architecture to
 both track state evolutions and plan for future objectives while
 remaining efficient enough to do these tasks in a real-time control 
loop.

\subsection{The Europa deliberative reactor}
\label{sec:arch:europa}

In T-REX architecture reactors have two core functions;
synchronization where the main focus is to track and refine the
evolution of the state of the world at any single tick, and
deliberation which focus on providing a plan to the agent in order to
complete the reactor {\em Internal} goals. These two processes are
intertwined in the sense that one influences the outcome of the
other. They are represented as two europa solvers modifying the same
plan database and for which the execution is managed by the T-REX 
framework as time advance during the execution of the system:
\begin{enumerate}
\item The synchronization solver is a specialized europa solver that
  will integrate in the plan new information about the evolution of
  the External state variable and ensure that the reactor propagate
  these in order to both identify its current state and inform
  other reactors of any state change on its internal timelines. This
  solver is summoned at the beginning of every single tick.
\item The deliberation solver is managing the deliberation process of
  the reactor in order to produce a new plan or alter its current plan
  as new goals are given to the reactor or the synchronization solver
  identifying a conflict between the current state of the world and
  the expectations of the previous plan. This process can  span other
  multiple tick and therefore can be interrupted at any single tick in
  order for the synchronization solver to do its task.
\end{enumerate}

While synchronization is assumed to be fast enough that it can be
resolved in less than a tick. Deliberation on the other hand can take
several ticks reflecting that automated planning can take time
depending on how far in the future the planner is looking ahead and
the complexity of the model. T-REX architecture, and more specifically
the europa based reactor in our case, takes this into account by
considering synchronization and deliberation as two concurrent tasks
with their own timing requirements and priority. 
While the two processes are separate, they share the same plan
internal to a reactor and therefore at every synchronization cycle the
planning process is informed of the new world state and its impact on
the plan. Conversely, when the planning process eventually finds a
solution, synchronization is informed about generating the planned
state values on the {\em external} state variables. This {\em
  external} plan defines the set of {\em goals} for this state
variable managed by another {\em reactor}. Fig. \ref{fig:tick-exec}
shows a conceptual view of these two tasks.


\begin{figure}[!htbp]
  \centering
  \vskip-1pc
  \includegraphics[width=0.55\columnwidth]{figs/tick-cycle}
  \caption{\small \texttt{T-REX} reactor execution cycle: {\em
      Deliberation} is interrupted by {\em synchronization} at the
    beginning of every {\em tick} allowing integration of state
    information.}
  \label{fig:tick-exec}
  \vskip-0.8pc
\end{figure}


In  this section we present how both processes are implemented using
the europa framework. We first present each of them independently by
looking to their specific focus. We then develop how both processes
are not only interleaved (as deliberation can take several tick while
synchronization eneds to happen at every single tick) but also discuss
on how each of these is impacting the other and how this intertwining 
of the two result on an emergent behavior of the reactor by allowing
the system to efficiently adapts its plan that can then be dispatched
as objectives for the reactors it depends on in a seamless flow. 




{\em fpy: I still wonder whether I should start with planning assuming
  first that the initial state is known and then develop
  synchronization and how it ties state information in to the plan or
  the other way around as it is now}

\subsubsection{Synchronization identify internal state evolution}
\label{sec:arch:synch}


For the sake of simplicity we introduce first how a reactor can track
and identify its state in the context where it does not have any
compelling need to deliberate. Assume here that we have a reactor that
have no future goal. {\em Need to develop the reason why it is a
  necessity: primarily to provide its internal state to whoever
  observe it but als simply to ensure that its current representation
  of the world is up to date and still consistent}

In the europa based reactor we introduce this requirement as a new
type of flaw for the europa framework. This flaw enforces at the
reactor to identify fully its internal state for the current
tick. By using this new flaw we can describe the synchronization
process as this general sequence :
\begin{enumerate}
\item Integrate the external state as provided by the owner of each
  external timeline into the plan database.
\item Propagate this information in the plan database following the
  model $\mathcal{M}$ of this reactor.
\item Resolve the current state value of each internal timelines.
\end{enumerate}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.5\columnwidth]{figs/synch-relation}
  \caption{Illustration of the synchronization flaws in a reactor. The
    reactor receive new observations when they are produced by the
    owner(s) of its internal timelines. The line after the last token
    of each timeline represent the domain of possible values for the
    end of this token. At every tick $\tau$ the reactor needs to
    integrate the {\em External} state information it received and --
    based on its model $\mathcal{M}$ -- resolve its {\em Internal}
    state that will then be provided by the architecture to other
    reactors using these state variables.}
  \label{fig:synch:flaw}
\end{figure}

The resolution of internal state flaw can be resolved using one of the
following choices which are evaluated in the given order:
\begin{enumerate}
\item Extend the previous state value to end after this tick (ie
  restrict its end time to $[\tau+1, \infty)$). 
\item Start the next active token in the timeline and
  attempt to start it now (ie restrict its start time to the single
  value $\tau$).
\item Create and insert a new token in this timeline that will start
  at the current tick $\tau$ (attempt this for each possible token
  type for this timeline if necessary). 
\end{enumerate}

All of these choices are evaluated sequentially until a consistent
solution with no more flaw for this tick is identified. In order to do
so we need to make the assumption that the current state value of an
internal timeline do not depend on the future or more accurately
that any choices made during this synchronization will not lead to a
future inconsistency (meaning no possible solution) for a future
synchronization. Such assumption deeply impact the set of possible
domains one the reactor can support while remaining complete. Take for
example the following model rule where {\tt Vehicle} is {\em Internal}
and {\tt Command} is {\em External} to the reactor.
\begin{verbatim}
Vehicle::Dive {
  contains(Command.Descend descend);
  descend.start = start + 2;
}
\end{verbatim}

Such model present the issue that the reactor needs at one point to
take the decision to start the token {\tt Vehicle.Dive} and by doing
so it assumes that in {\em exactly} 2 ticks in the future the {\tt
  Command} timeline will change its state to {\tt Command.Descend}. If
this observation does not occur at the given time this implies that
the reactor estimation was wrong leading him to an inconsistent view
of the world. Conversely the reactor can decide to not switch this
timeline to the {\tt Vehicle.Dive} state and observe 2 ticks in the
future that the {\tt Command.Descend} state value. In this case it
would have missed the opportunity to set its {\tt Vehicle} state to
the correct value which may similarly lead (depending on the rest of
the model) to a similar inconsistency it won't be able to resolve (as
TREX enforces that  the past is monotonic).

While this limitation of the system is important to take into account,
it is also important to note that the model snippet we gave here --
while formally acceptable in the general planning problem -- is also
illustrating a bad design for execution in a situated agent. Indeed,
in this model we are tying the current decision to a future outcome
that is {\em External} to the reactor and therefore not necessarily
controllable by this reactor. Therefore we are entailing a part of the
future to past decisions which can lead the system to a dead-end
situation where the model cannot find a correct solution that both do
not conflict with what we claimed in the past and still allow the
planner to find its current {\em Internal} state.

Synchronization remains here a deliberation process, and for this
reason there's always the risk that the search of a solution is not a
straightforward sequence of unit decision. As such process is required
by the architecture at every ticks for every reactors presently
running this need to be carefully designed. At the engine level we
made careful choices in term of both the focus of the search -- limited
only to tokens that can potentially overlap the current tick -- and
its heuristic where the internal state flaw is considered last during
the search. The later proved to limit the amount of backtrack in the
search for a solution -- or at least how deep we need to backtrack in
our decision tree -- similarly the sequence in which we evaluate the
possible resolution for such a flaw -- presented previously -- was
selected according to simple assumptions that takes benefit of a
possibly already existing plan by assuming that if the outcome of
synchronization appears consistent with our current plan then it
probably reflects that this reactor plan is executed. Such assumption
helps direct the internal state evaluation and, in nominal cases (where
we assume that reactors are acting in concert), proved to be a sound
solution.  

One final aspect to keep into account is that in T-REX point of view
synchronization is the only critical task of a reactor. Indeed, such
process is used in order for the agent to identify its
current state and maintain it consistent throughout the agent
life-time. A reactor not being able to find a consistent solution
during synchronization -- meaning that after evaluating all the
possible solutions provided by its model it did not found any plan
that is not inconsistent -- not only expresses that this reactor is
not able anymore to explain the state of the world but may jeopardize
other reactors that relies on its {\em internal} state. For this
reason a failure to do synchronization immediately result on the
agent killing this reactor and notifying any reactor that depends on
its {\em internal} state variables by posting the special observation
\textsf{Failed}. By doing so we allow for graceful degradation where
other reactors can readapt their plan as they receive this
\textsf{Failed} observation.

\subsubsection{Deliberation : planning for future state evolution}
\label{sec:arch:plan}

The planning process inside a reactor is directly based on the way
europa work which was described in previous section. Still some simple
alterations were made in  order to both include deliberation
information one reactor provide to the architecture -- such as its
deliberation latency and its planning look-ahead both expressed in 
ticks -- and the fact that we potentially need to interleave this
deliberation with not the synchronization process but also with 
the deliberation of other reactors\footnote{Current implementation of
  T-REX is running on a single process and it is the responsibility of
  the agent itself to emulate the multi-threading of the reactors
  deliberation and synchronization}. For this reason we 
decompose the algorithm \ref{alg:europa:solve} inside the reactor by
having the recursive calls decomposed in single steps. This step
function will be called after synchronization and as long as the
previous call in this tick did not return \textsf{true} -- which would
express that the current solution is complete.
{\em will need to change that in algorithm environment and refine it}

\begin{verbatim}
bool step(PartialPlan plan, DecisionStack stack) 
   if( isInconsistent(plan) ) {
     relaxPlan(plan, stack);
     notify("No plan");
     return true;
   } 
   Flaw flaw = chooseFlaw(flaw);
   if( flaw==NULL )
     return true;
   DecisionPoint decision = makeDecisionPoint(flaw, plan);
   while(1) {
     while( decision.hasNext() ) {
       PartialPlan pp = decision.executeNext();
       if( isInconsistent(pp) ) {
         decision.undo();
       }  else {
          plan = pp;
          stack.push(decision);
          return chooseFlaw(flaw)==NULL;
       }
     }
     if( decisionStack.empty() ) {
       notify("No plan");
       return true;
     } else {
        repeat {
          decision = decisionStack.pop();
          decision.undo();
        } until( decision.hasNext() );
        return false;
     }
   } 
}
\end{verbatim}

One critical aspect of this deliberation step is to ensure that at the
exit of this call the $plan$ is not proven inconsistent. Indeed, it is
always possible that the next call made by the agent is the
synchronization which would immediately fail if the $plan$ is
inconsistent before any solving attempt made for synchronization. 
For this reason if the plan is proven inconsistent during a
deliberation step we either backtrack in the decision stack until we
find a node fo the tree that have remaining alternate solution or
simply fully relax the plan in situation there's absolutely no other
alternative  (by removing all the goals and keeping
only recent observations produced). These constraints are yet again
related to the fact that for the agent the only crucial functionality
of a reactor is to resolve successfully its synchronization. 

The number of flaw between two steps can evolve for the following
reasons that are exogenous to deliberation :
\begin{enumerate}
\item A new goal has been posted on one of the reactor timeline. This
  is usually due to another reactor finding a plan and posting the
  corresponding new objective to this reactor.
\item The outcome of synchronization created new flaws that did not
  need to be resolved during synchronization.
\item A previously requested goal has be recalled by the initial
  requester. This can happen when the reactor did identify that is
  initial plan is no longer valid. For example as synchronization
  proved this plan to be inconsistent.
\end{enumerate}
These 3 events will potentially produce new flaws to be resolved while
any single deliberation step will usually reduce the number of flaws
to be resolved.

The scope of planning for the reactor plays also a role in the
deliberation process as we limit deliberation to the sliding temporal
window $[\tau+\lambda, \tau+\lambda+\pi]$ where:
\begin{itemize}
\item $\tau$ is the current tick
\item $\lambda$ is the specified latency of this reactor. Which is an
  indicator on the expected maximum time this reactor is expected
  before being able to produce a plan.\footnote{Do note that this
    parameter remains indicative and, while it is highly recommended to
    select a sound value, a failure to produce a plan in this delay is
    not considered as a critical failure of the reactor}
\item $\pi$ is the planning look-ahead of the reactor. which indicates
  how many ticks in the future this reactor is looking ahead while planning.
\end{itemize}
This scope allow to filter out any tokens that are either necessarily
ending before $\tau$ or necessarily starting after. Focusing the
[planning problem to only the tokens that are in a reasonable
future. This window is taken into account by the agent which will
notify the reactor of new {\em internal} goals only when they overlap
this window but also at the deliberation solver in order to reduce the
number of tokens to be evaluated and consequently reduce the cost of
deliberation. As time advance flaws that where initially beyond this
window will become active flaw that the reactor can then evaluate
resulting on an apparent continuous planning of the reactor.


When there's no more flaw is present in the current planning scope a
plan  solution is found. This has two effects:
\begin{enumerate}
\item This reactor does not need to deliberate until the next synchronization.
\item The {\em external} part of this plan can then be posted which
  eventually (at the end of the current tick if these goals overlap
  the owner planning window) will be dispatched as goals triggering
  new deliberation on these reactors.
\end{enumerate}





\subsubsection{Intertwining synchronization and execution }
\label{sec:arch:intertwine}




% Gives a high-level overview of T-REX, the general design principles and how
% these principles aid in software engineering. Show T-REX block diagram.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "setobook"
%%% End: 
